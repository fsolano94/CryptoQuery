Rest is about modeling API around resources and clients perform operations on those resources.

A Resource is any object inside the API's design domain.

Endpoints in a Restful API are resources or collections of those resources.

Relationships between data are represented by links between resources in the API.

Allow clients to act on resources.

Representing that state of change.

REST vs RPC (Remote Procedure Call )

Rest:
*Endpoints are nouns and represent resources that can be acted upon.
*Calling the endpoint is acting on the resource.
*Returns resources that were acted upon.
*Resource oriented.
*Use when:
-API is data driven.
-Want to emphasize links between data.
-Example of REST API is PayPal API.

RPC:
*Endpoints are verbs (methods).
*Calling the endpoint is calling the method (similar to calling a function).
*Returns results of the function call.
*Function oriented.
*Use when:
-API is action driven.
-Want to provide a strict set of interactions.
-Eample of RPC API is Slack API.

Every API is different (One size doesn't fit all).


HATEOS (Hypermedia As the Engine of Application State)
= The responses from the API tell the client what it can do in addition to including details of the resource acted upon.

Client only needs to look at the API responses to understand what it can do. What actions are possible varies depending on the resource and application state.
Client does not need any rules about how the API works.

Responses should include links to the actions available.

Single root entry point.

No need for client to need more information about API.

HTTP Methods:

HTTP methods are verbs that act on a resource in a RESTful API.

GET and HEAD retreive the information of a resource (both are read only and never change application state these are known as safe methods).

POST is used to create resources when the resource id is not known in advance. Use POST for creating resources or partial updates to existing resources.

Idempotent Methods = The effect of multiple identical requests is the same as one request (i.e GET).

Idempotency matters because it can be retried without risking side effects.

PUT can be used to create or update a resource and is required to be idempotent. This means that the full URI must be known by the HTTP spec. URI is known the client instead of being generated by the server. Use PUT to create or fully update resources with a known ID (upsert).

PATCH can be used for partial updates because it is not idempotent because the resource state on the server may change between retries.


DELETE deletes a resource with a known id and is an idempotent method.

Common Update Semantics:
Approach 1:
*POST to create.
*PUT for full updates.
*PATCH for partial updates.

Approach 2:
*POST to create or update.
*Simpler and easier but no idempotent update capability (treat all updates as partial updates).


Principles of REST and HATOES are format agnostics meaning the API can return a response XML, JSON or something else entirely.

JSON is increasingly popular.
Advantages:
*lightweight and easy to read.
*easy for machines to read since no need for heavy parsing engine.
Disadvantages:
*Loose and no enforced schema

Use a standardized schema for REST and JSON.
Popular REST and JSON Approaches.
*JSON API (jsonapi.org)
*HAL
*ION (ionwg.org)
*JSON Schema
*Collection + JSON

ION JSON based specification for Hypermedia and RESTful API's. Designed to be intuitive.

Links in ION are JSON objects with an href property.

launchsettings.json contains info passed to IIS.

Startup.cs file contains three important method:
*Ctor = read appsettings.json which contains application specific information
*ConfigureServices = can add services to Dependency injection system. Order of calls doesn't matter.
*Configure = sets up application pipeline Order of calls does matter.

Create a Root Controller. [Route("/")]

Approaches to RESTful Versioning:
1. Don't version (clients should be dynamic).
2. Media type (header) versioning.
GET /{resource}
Accept: application/{media-type};v={version number}.
3. URL prefix versioning:
https://example.io/v1/{resource}.

We'll do Media Type versioning.


API Security:
*2 Types:
1) Transport security.
-keep connection between client and server secure.
-enable HTTPS, and make it required.
-additional security headers

2) Application security.

ASP.NET Core sites run on Kestrel by default:

Internet => Reverse Proxy => Kestrel => ASP.NET Core.













